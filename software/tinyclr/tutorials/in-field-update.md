# In-Field Update
---
TinyCLR OS allows for secure, encrypted, In-Field Update (IFU) of your application.

> [!Note]
> The application key is generated by the [**TinyCLR Config**](../tinyclr-config.md) tool when you create your application.

In-Field Update only work with streams, these stream can be MemoryStream, FileStream or NetworkStream.

 

## Update via MemoryStream
Systems with external memory can create a stream from buffer, which first copies the new update from a file, network, or bus, and stores it in a buffer. When the entire firmware file is in memory, the IFU will then check the stream for authenticity. Only then will it decrypt the data and flash it into the chip's internal memory.

It doesn't matter to IFU if the memoryStream is created from managed heap or unmanaged heap. In most cases, unmanaged memory is the only memory large enough to hold the firmware buffer. However, if the managed heap has been extended to external memory (see the [External Memory](external-memory.md) page), then managed heap must be used as there is no longer any unmanaged heap space.

Update via memoryStream is the recommended update mode, but it only works on systems with external memory.

> [!Warning]
> Be careful not to interrupt power during application for firmware updates. A power interruption will cause the update to fail making it necessary to manually update your board.

> [!Tip]
> Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Update.

```cs
var fwBuf = YourFirmwareBuffer;
var appBuf = YourApplicationBuffer;

var memoryStreamFirmware = new MemoryStream(fwBuf);
var memoryStreamApplication = new MemoryStream(appBuf);
var useExternalFlash = true;

var appKey = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

updater = new InFieldUpdate(memoryStreamFirmware, memoryStreamApplication, appKey, useExternalFlash);

updater.Build(true, true);  

Debug.WriteLine("Firmware version: " + updater.FirmwareVersion);
Debug.WriteLine("Aplication version: " + updater.ApplicaltionVersion);

updater.FlashAndReset();
           
```

---

## Update via File

The file updater reads files from memory, SD card or USB port, and then handles the update directly without the need for external memory.

> [!Warning]
> Be careful not to interrupt power during the update of your board. A power interruption will cause the update to fail making it necessary to manually update your board.

> [!Tip]
> Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Update.

```cs
var useExternalFlash = true;
var filestreamApp = new FileStream(@"yourapplication.tca", FileMode.Open);
var filestreamFw = new FileStream(@"yourfirmware.ghi", FileMode.Open);

var appKey = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

updater = new InFieldUpdate(firmwareNetworkStream, appNetworkStream, appKey, useExternalFlash);

updater.Build(true, true);                                     

Debug.WriteLine("Firmware version: " + updater.FirmwareVersion);
Debug.WriteLine("Aplication version: " + updater.ApplicaltionVersion);

updater.FlashAndReset();
```

## Update via Network
Beside MemoryStream, FileStream, IFU allows update through network as well. To do this, we need to create a network stream from socket.

> [!Warning]
> Be careful not to interrupt power during the update of your board. A power interruption will cause the update to fail making it necessary to manually update your board.

> [!Tip]
> Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Update.

```

var appSocket = socket.Accept();
var firmwareSocket = socket.Accept();

var firmwareNetworkStream = new NetworkStream(firmwareSocket);
var appNetworkStream = new NetworkStream(appSocket);
var useExternalFlash = true;


var appKey = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

var updater = new InFieldUpdate(firmwareNetworkStream, appNetworkStream, appKey, useExternalFlash);

// updater.Build(false, true); // Read application stream only
// updater.Build(true, false); // Read firmare stream only
updater.Build(true, true); // Read application first, then firmare.

Debug.WriteLine("Firmware version: " + updater.FirmwareVersion);
Debug.WriteLine("Aplication version: " + updater.ApplicaltionVersion);

updater.FlashAndReset();

```

---

## Firmware and Application Must Match
It is important that the firmware on your chip is the same version expected by your application. To make sure your application and firmware match, it is best to update both simultaneously if possible.
